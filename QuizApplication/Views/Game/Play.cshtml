@{
    ViewData["Title"] = "Gra";
    Layout = "_GameLayout";
    var sessionId = ViewBag.SessionId;
    var playerId = ViewBag.PlayerId;
    var isHost = ViewBag.IsHost;
    var quizTitle = ViewBag.QuizTitle;
    var totalQuestions = ViewBag.TotalQuestions;
}

<!-- Game Header -->
<div class="game-header">
    <div class="question-counter">
        <span id="questionNumber">-</span> / <span id="totalQuestions">@totalQuestions</span>
    </div>
    <div class="text-center">
        <span class="text-white-50">@quizTitle</span>
    </div>
    <div class="timer-container">
        <svg class="timer-circle" width="80" height="80">
            <circle class="timer-circle-bg" cx="40" cy="40" r="34"></circle>
            <circle class="timer-circle-progress" id="timerProgress" cx="40" cy="40" r="34"
                    stroke-dasharray="213.6" stroke-dashoffset="0"></circle>
        </svg>
        <span class="timer-text" id="timerText">--</span>
    </div>
</div>

<!-- Main Content -->
<div class="question-container" id="questionContainer">
    <div class="waiting-container">
        <i class="bi bi-hourglass-split waiting-icon"></i>
        <p class="waiting-text">Łączenie z grą...</p>
        <p class="text-white-50" id="connectionStatusText">Nawiązywanie połączenia...</p>
    </div>
</div>

<!-- Host Panel (tylko dla hosta) -->
@if (isHost)
{
    <div class="host-panel" id="hostPanel" style="display: none;">
        <div class="host-stats">
            <div class="host-stat">
                <div class="host-stat-value" id="answeredCount">0</div>
                <div class="host-stat-label">Odpowiedziało</div>
            </div>
            <div class="host-stat">
                <div class="host-stat-value" id="totalPlayers">0</div>
                <div class="host-stat-label">Graczy</div>
            </div>
        </div>
    </div>
}

@section Scripts {
    <script>
        const sessionId = '@sessionId';
        const playerId = '@(playerId ?? "")';
        const isHost = @(isHost.ToString().ToLower());

        let connection = null;
        let currentQuestion = null;
        let timerInterval = null;
        let timeLeft = 0;
        let hasAnswered = false;
        let questionStartTime = null;
        let selectedAnswers = []; // Dla pytań wielokrotnego wyboru

        async function initGame() {
            connection = new signalR.HubConnectionBuilder()
                .withUrl("/quizHub")
                .withAutomaticReconnect()
                .build();

            // Event handlers
            connection.on("QuestionStarted", handleQuestionStarted);
            connection.on("RoundEnded", handleRoundEnded);
            connection.on("YourRoundResult", handleYourResult);
            connection.on("TopPlayers", handleTopPlayers);
            connection.on("GameFinished", handleGameFinished);
            connection.on("YourFinalRanking", handleYourFinalRanking);
            connection.on("GameCancelled", handleGameCancelled);
            connection.on("GameMessage", handleGameMessage);
            connection.on("AnswerCountUpdate", handleAnswerCount);

            connection.onreconnecting(() => {
                document.getElementById('connectionStatusText').textContent = 'Ponowne łączenie...';
            });

            connection.onreconnected(async () => {
                document.getElementById('connectionStatusText').textContent = 'Połączono ponownie';
                // Ponownie dołącz do sesji
                await joinGameSession();
            });

            connection.onclose(() => {
                document.getElementById('connectionStatusText').textContent = 'Rozłączono';
                showToast('Utracono połączenie z serwerem', 'error');
            });

            try {
                await connection.start();
                console.log("SignalR connected");
                document.getElementById('connectionStatusText').textContent = 'Połączono - dołączanie do gry...';

                // Dołącz do sesji gry
                await joinGameSession();

            } catch (error) {
                console.error("Connection error:", error);
                document.getElementById('connectionStatusText').textContent = 'Błąd połączenia';
                showToast('Błąd połączenia z serwerem', 'error');
            }
        }

        async function joinGameSession() {
            try {
                console.log("Wywołuję JoinGameSession:", { sessionId, playerId, isHost });

                const success = await connection.invoke("JoinGameSession", sessionId, playerId || null, isHost);

                console.log("JoinGameSession result:", success);

                if (success) {
                    console.log("Dołączono do sesji gry");
                    document.getElementById('connectionStatusText').textContent = 'Oczekiwanie na pytanie...';

                    // Pokaż odpowiedni komunikat
                    const container = document.getElementById('questionContainer');
                    container.innerHTML = `
                        <div class="waiting-container">
                            <i class="bi bi-hourglass-split waiting-icon"></i>
                            <p class="waiting-text">Przygotuj się...</p>
                            <p class="text-white-50">Gra zaraz się rozpocznie</p>
                        </div>
                    `;
                } else {
                    console.error("JoinGameSession zwróciło false");
                    document.getElementById('connectionStatusText').textContent = 'Błąd dołączania';
                    showToast('Nie udało się dołączyć do gry', 'error');
                }
            } catch (error) {
                console.error("JoinGameSession error:", error);
                document.getElementById('connectionStatusText').textContent = 'Błąd dołączania';
                showToast('Błąd dołączania do gry: ' + error.message, 'error');
            }
        }

        function handleQuestionStarted(question) {
            console.log("Question started:", question);
            currentQuestion = question;
            hasAnswered = false;
            selectedAnswers = []; // Reset wybranych odpowiedzi
            questionStartTime = Date.now();

            document.getElementById('questionNumber').textContent = question.questionNumber;

            if (isHost) {
                document.getElementById('hostPanel').style.display = 'block';
                document.getElementById('answeredCount').textContent = '0';
            }

            renderQuestion(question);
            startTimer(question.timeLimitSeconds);
        }

        function renderQuestion(question) {
            const container = document.getElementById('questionContainer');

            let imageHtml = '';
            if (question.imageUrl) {
                imageHtml = `<img src="${question.imageUrl}" class="question-image" alt="Obrazek pytania" />`;
            }

            // Sprawdź czy to pytanie wielokrotnego wyboru
            const isMulti = question.isMultipleChoice;
            const correctCount = question.correctAnswersCount || 1;

            let hintHtml = '';
            if (isMulti && !isHost) {
                hintHtml = `<p class="text-info mb-3"><i class="bi bi-info-circle me-2"></i>W tym pytaniu ${correctCount === 2 ? 'są 2 poprawne odpowiedzi' : correctCount === 3 ? 'są 3 poprawne odpowiedzi' : correctCount === 4 ? 'są 4 poprawne odpowiedzi' : 'jest ' + correctCount + ' poprawnych odpowiedzi'}</p>`;
            }

            let answersHtml = question.answers.map((answer, index) => `
                <button class="answer-btn" data-answer-id="${answer.answerId}" onclick="${isMulti ? 'toggleAnswer' : 'selectAnswer'}(${answer.answerId})" ${isHost ? 'disabled' : ''}>
                    ${answer.content}
                </button>
            `).join('');

            let submitBtnHtml = '';
            if (isMulti && !isHost) {
                submitBtnHtml = `
                    <div class="mt-3">
                        <button id="submitMultiBtn" class="btn btn-primary btn-lg" onclick="submitMultiAnswer()" disabled>
                            <i class="bi bi-check2-all me-2"></i>Zatwierdź odpowiedzi
                        </button>
                    </div>
                `;
            }

            container.innerHTML = `
                <h2 class="question-text">${question.content}</h2>
                ${imageHtml}
                ${hintHtml}
                <div class="answers-grid" id="answersGrid">
                    ${answersHtml}
                </div>
                ${submitBtnHtml}
                ${isHost ? '<p class="text-white-50 mt-3"><i class="bi bi-eye"></i> Tryb hosta - obserwujesz grę</p>' : ''}
            `;
        }

        // Dla pytań jednokrotnego wyboru
        async function selectAnswer(answerId) {
            if (hasAnswered || isHost || timeLeft <= 0) return;

            hasAnswered = true;
            const responseTime = (Date.now() - questionStartTime) / 1000;

            // Zaznacz wybraną odpowiedź
            document.querySelectorAll('.answer-btn').forEach(btn => {
                btn.disabled = true;
                if (parseInt(btn.dataset.answerId) === answerId) {
                    btn.classList.add('selected');
                }
            });

            // Wyślij odpowiedź (jako lista z jednym elementem)
            await sendAnswers([answerId], responseTime);
        }

        // Dla pytań wielokrotnego wyboru - przełączanie zaznaczenia
        function toggleAnswer(answerId) {
            if (hasAnswered || isHost || timeLeft <= 0) return;

            const btn = document.querySelector(`[data-answer-id="${answerId}"]`);
            const index = selectedAnswers.indexOf(answerId);

            if (index > -1) {
                // Odznacz
                selectedAnswers.splice(index, 1);
                btn.classList.remove('selected');
            } else {
                // Zaznacz
                selectedAnswers.push(answerId);
                btn.classList.add('selected');
            }

            // Aktualizuj stan przycisku zatwierdzania - aktywny gdy ≥1 odpowiedź
            const submitBtn = document.getElementById('submitMultiBtn');
            if (submitBtn) {
                submitBtn.disabled = selectedAnswers.length === 0;
            }
        }

        // Zatwierdzenie odpowiedzi wielokrotnego wyboru
        async function submitMultiAnswer() {
            if (hasAnswered || isHost || selectedAnswers.length === 0 || timeLeft <= 0) return;

            hasAnswered = true;
            const responseTime = (Date.now() - questionStartTime) / 1000;

            // Zablokuj wszystkie przyciski
            document.querySelectorAll('.answer-btn').forEach(btn => {
                btn.disabled = true;
            });

            const submitBtn = document.getElementById('submitMultiBtn');
            if (submitBtn) {
                submitBtn.disabled = true;
                submitBtn.innerHTML = '<i class="bi bi-hourglass-split me-2"></i>Wysyłanie...';
            }

            await sendAnswers(selectedAnswers, responseTime);
        }

        // Wspólna funkcja wysyłania odpowiedzi
        async function sendAnswers(answerIds, responseTime) {
            try {
                const result = await connection.invoke("SubmitAnswer", sessionId, playerId, {
                    answerIds: answerIds,
                    responseTimeSeconds: responseTime
                });

                if (!result.success) {
                    showToast(result.errorMessage || 'Błąd wysyłania odpowiedzi', 'error');
                }
            } catch (error) {
                console.error("Submit error:", error);
                showToast('Błąd połączenia', 'error');
            }

            // Pokaż stan oczekiwania
            showWaitingState();
        }

        function startTimer(seconds) {
            timeLeft = seconds;
            const totalTime = seconds;
            const circumference = 2 * Math.PI * 34; // 213.6

            updateTimerDisplay();

            // Reset timer circle
            document.getElementById('timerProgress').style.strokeDashoffset = 0;
            document.getElementById('timerText').className = 'timer-text';

            if (timerInterval) clearInterval(timerInterval);

            timerInterval = setInterval(() => {
                timeLeft -= 0.1;

                if (timeLeft <= 0) {
                    timeLeft = 0;
                    clearInterval(timerInterval);

                    // Zablokuj wszystkie przyciski odpowiedzi gdy czas się skończył
                    if (!hasAnswered) {
                        document.querySelectorAll('.answer-btn').forEach(btn => {
                            btn.disabled = true;
                        });
                        const submitBtn = document.getElementById('submitMultiBtn');
                        if (submitBtn) {
                            submitBtn.disabled = true;
                            submitBtn.innerHTML = '<i class="bi bi-clock-history me-2"></i>Czas minął';
                        }
                    }
                }

                updateTimerDisplay();

                // Update circle
                const progress = timeLeft / totalTime;
                const offset = circumference * (1 - progress);
                document.getElementById('timerProgress').style.strokeDashoffset = offset;

                // Color warnings
                const timerText = document.getElementById('timerText');
                if (timeLeft <= 5) {
                    timerText.className = 'timer-text timer-danger';
                } else if (timeLeft <= 10) {
                    timerText.className = 'timer-text timer-warning';
                }
            }, 100);
        }

        function updateTimerDisplay() {
            document.getElementById('timerText').textContent = Math.ceil(timeLeft);
        }

        function showWaitingState() {
            const container = document.getElementById('questionContainer');

            // Dodaj overlay oczekiwania
            const waitingOverlay = document.createElement('div');
            waitingOverlay.className = 'waiting-container';
            waitingOverlay.id = 'waitingOverlay';
            waitingOverlay.innerHTML = `
                <i class="bi bi-check-circle waiting-icon text-success"></i>
                <p class="waiting-text">Odpowiedź zapisana!</p>
                <p class="answered-count">Oczekiwanie na innych graczy...</p>
            `;
            waitingOverlay.style.position = 'absolute';
            waitingOverlay.style.top = '50%';
            waitingOverlay.style.left = '50%';
            waitingOverlay.style.transform = 'translate(-50%, -50%)';
            waitingOverlay.style.background = 'rgba(0,0,0,0.8)';
            waitingOverlay.style.padding = '2rem';
            waitingOverlay.style.borderRadius = '20px';
            waitingOverlay.style.zIndex = '10';

            container.style.position = 'relative';
            container.appendChild(waitingOverlay);
        }

        function handleRoundEnded(results) {
            console.log("Round ended:", results);
            clearInterval(timerInterval);

            // Pobierz listę poprawnych odpowiedzi (obsługuje multi-choice)
            const correctIds = results.correctAnswerIds || [];

            // Pokaż poprawne odpowiedzi
            document.querySelectorAll('.answer-btn').forEach(btn => {
                btn.disabled = true;
                const answerId = parseInt(btn.dataset.answerId);

                if (correctIds.includes(answerId)) {
                    btn.classList.add('correct');
                } else if (btn.classList.contains('selected')) {
                    btn.classList.add('incorrect');
                }
            });

            // Ukryj przycisk zatwierdzania (dla multi-choice)
            const submitBtn = document.getElementById('submitMultiBtn');
            if (submitBtn) submitBtn.style.display = 'none';

            // Usuń overlay oczekiwania
            const overlay = document.getElementById('waitingOverlay');
            if (overlay) overlay.remove();
        }

        function handleYourResult(result) {
            console.log("Your result:", result);

            // Pokaż wynik gracza
            const container = document.getElementById('questionContainer');
            const resultDiv = document.createElement('div');
            resultDiv.className = 'result-container';
            resultDiv.innerHTML = `
                <div class="result-icon ${result.isCorrect ? 'correct' : 'incorrect'}">
                    <i class="bi bi-${result.isCorrect ? 'check-circle-fill' : 'x-circle-fill'}"></i>
                </div>
                ${result.isCorrect ? `
                    <div class="result-points">+${result.pointsAwarded}</div>
                    <div class="text-success">Czas: ${result.responseTimeSeconds.toFixed(2)}s</div>
                ` : `
                    <div class="result-points text-danger">+0</div>
                `}
                <div class="result-rank mt-3">
                    Pozycja: <strong>${result.currentRank}</strong> |
                    Suma: <strong>${result.totalScore}</strong> pkt
                </div>
            `;
            container.appendChild(resultDiv);
        }

        function handleTopPlayers(data) {
            console.log("Top players:", data);

            const container = document.getElementById('questionContainer');
            const topDiv = document.createElement('div');
            topDiv.className = 'top-players';

            topDiv.innerHTML = data.players.map((player, index) => `
                <div class="top-player-card ${index === 0 ? 'rank-1' : ''}">
                    <div class="top-player-rank">${index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : index + 1}</div>
                    <div class="top-player-nick">${player.nickname}</div>
                    <div class="top-player-score">${player.totalScore} pkt</div>
                    ${player.pointsThisRound > 0 ? `<div class="top-player-points">+${player.pointsThisRound}</div>` : ''}
                </div>
            `).join('');

            container.appendChild(topDiv);
        }

        function handleAnswerCount(data) {
            if (isHost) {
                document.getElementById('answeredCount').textContent = data.answeredCount;
                document.getElementById('totalPlayers').textContent = data.totalPlayers;
            }
        }

        function handleGameFinished(ranking) {
            console.log("Game finished:", ranking);
            // Zapisz ranking do localStorage i przekieruj
            localStorage.setItem('finalRanking', JSON.stringify(ranking));
            window.location.href = `/Game/Results?sessionId=${sessionId}&playerId=${playerId}&isHost=${isHost}`;
        }

        function handleYourFinalRanking(ranking) {
            // Zapisz ranking do localStorage dla strony wyników
            localStorage.setItem('finalRanking', JSON.stringify(ranking));
        }

        function handleGameCancelled(message) {
            showToast(message.message, 'error');
            setTimeout(() => {
                window.location.href = '/';
            }, 2000);
        }

        function handleGameMessage(message) {
            showToast(message.message, message.type);
        }

        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `game-toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);

            setTimeout(() => {
                toast.style.animation = 'slideIn 0.3s ease reverse';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // Init
        initGame();
    </script>
}
